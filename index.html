<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NitroType Team + Racer Leaderboards (Robust Skull)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #111317;
      --surface: #151922;
      --surface-2: #1b2130;
      --surface-3: #212838;
      --text: #e8ecf1;
      --text-dim: #b5c0cf;
      --muted: #8b9ab3;
      --accent: #6ea8fe;
      --accent-2: #8fdaff;
      --good: #37d67a;
      --warn: #ffb020;
      --bad: #ff5c5c;
      --border: #2a3244;
      --shadow: rgba(0,0,0,0.35);
      --focus: #82b1ff;

      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;

      --pad-1: 0.4rem;
      --pad-2: 0.66rem;
      --pad-3: 1rem;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    html, body { background: var(--bg); color: var(--text); font-family: var(--font); margin: 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .wrap { max-width: 1200px; margin: 0 auto; padding: var(--pad-3); }
    header { display: flex; align-items: center; justify-content: space-between; gap: var(--pad-2); margin-bottom: var(--pad-3); }
    .title { font-size: 1.6rem; font-weight: 700; letter-spacing: .2px; }
    .sub { color: var(--muted); font-size: .95rem; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      background: var(--surface-3);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 6px 12px;
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    input[type="file"] {
      background: var(--surface-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--pad-2);
      outline: none;
    }
    input[type="file"]:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--focus) 25%, transparent);
    }

    .card {
      background: linear-gradient(180deg, var(--surface), var(--surface-2));
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: 0 10px 24px var(--shadow);
      margin-bottom: var(--pad-3);
      overflow: hidden;
    }
    .card h2 {
      margin: 0;
      padding: var(--pad-2) var(--pad-3);
      font-size: 1.15rem;
      border-bottom: 1px solid var(--border);
      background: var(--surface-3);
    }
    .card .body { padding: var(--pad-3); }

    .badge {
      display: inline-block;
      padding: 0.15rem 0.6rem;
      border-radius: var(--radius-sm);
      font-size: 0.85rem;
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text-dim);
    }
    .badges { display: flex; gap: 8px; flex-wrap: wrap; }

    .tabs {
      display: flex; gap: 6px; flex-wrap: wrap; border-bottom: 1px solid var(--border);
      padding: var(--pad-1) var(--pad-2);
    }
    .tab {
      padding: var(--pad-2) var(--pad-3);
      cursor: pointer;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      color: var(--text-dim);
      user-select: none;
    }
    .tab.active { background: var(--surface-3); color: var(--text); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    table { width: 100%; border-collapse: collapse; font-size: .94rem; }
    thead th {
      text-align: left; padding: var(--pad-2) var(--pad-3);
      color: var(--text-dim); background: var(--surface-3);
      position: sticky; top: 0; z-index: 1;
    }
    tbody td { padding: var(--pad-2) var(--pad-3); border-top: 1px solid var(--border); vertical-align: middle; }
    tbody tr:hover { background: color-mix(in srgb, var(--surface-2) 70%, var(--surface-3)); }
    .num { font-family: var(--mono); color: var(--text); }
    .muted { color: var(--muted); }
    .scroll { max-height: 560px; overflow: auto; }

    .error { color: var(--bad); margin-top: 6px; }
    .ok { color: var(--good); }
    .warn { color: var(--warn); }

    .progress {
      height: 8px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin-top: 8px;
    }
    .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width .25s ease;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">NitroType Leaderboards (Robust Skull)</div>
        <div class="sub">Loads a large data.json, dedupes teams, extracts racers, and builds top‑100 leaderboards with failsafes.</div>
      </div>
      <div class="controls">
        <button id="reloadBtn">Reload data.json</button>
        <button id="saveJSON" disabled>Save aggregated JSON</button>
        <span class="badge" id="lastUpdated">Last updated: —</span>
      </div>
    </header>

    <div class="card">
      <h2>Summary</h2>
      <div class="body">
        <div class="badges">
          <span class="badge" id="teamsCount">Teams (deduped): 0</span>
          <span class="badge" id="racersCount">Racers: 0</span>
          <span class="badge" id="exportsCount">Exports ingested: 0</span>
          <span class="badge">Dedup: teamTag (fallback teamName), keep latest exportedAtISO</span>
        </div>
        <div id="errorBox" class="error" style="display:none;"></div>
        <div class="progress" id="progress" style="display:none;"><div class="bar" id="progressBar"></div></div>
      </div>
    </div>

    <div class="card">
      <h2>Leaderboards</h2>
      <div class="tabs">
        <div class="tab active" data-tab="lb-racer-teamRaces">Team races (racers)</div>
        <div class="tab" data-tab="lb-tenure">Longest member since (racers)</div>
        <div class="tab" data-tab="lb-active">Most active (racers)</div>
        <div class="tab" data-tab="lb-team-totals">Team total races (stats.allTime)</div>
      </div>

      <div id="lb-racer-teamRaces" class="tab-content active">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th class="num">Team Races</th>
              </tr>
            </thead>
            <tbody id="tbody-racer-teamRaces"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-tenure" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th>Member Since</th>
                <th class="num">Parsed (ISO)</th>
              </tr>
            </thead>
            <tbody id="tbody-tenure"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-active" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th>Last Race</th>
                <th class="num">Parsed (ISO)</th>
              </tr>
            </thead>
            <tbody id="tbody-active"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-team-totals" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Team</th>
                <th class="num">All‑Time Races</th>
                <th class="num">Avg Speed</th>
                <th class="num">Avg Accuracy</th>
                <th class="muted">Source URL</th>
              </tr>
            </thead>
            <tbody id="tbody-team-totals"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Preview (first 50 racers)</h2>
      <div class="body scroll">
        <table id="racersTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Username</th>
              <th>Team</th>
              <th class="num">Team Races</th>
              <th class="num">Total Races</th>
              <th class="num">Avg WPM</th>
              <th class="num">High Speed</th>
              <th>Member Since</th>
              <th>Last Race</th>
            </tr>
          </thead>
          <tbody id="previewRacers"></tbody>
        </table>
        <div class="muted" style="margin-top:8px;">Large datasets are processed off the main thread; preview shows only first 50.</div>
      </div>
    </div>

    <div class="card">
      <h2>Preview (teams)</h2>
      <div class="body scroll">
        <table id="teamsTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>Tag</th>
              <th>Members</th>
              <th>Formed</th>
              <th class="num">Page Views</th>
              <th class="num">All‑Time Races</th>
              <th class="num">Avg Speed</th>
              <th class="num">Avg Accuracy</th>
              <th>Exported At</th>
            </tr>
          </thead>
          <tbody id="previewTeams"></tbody>
        </table>
      </div>
    </div>
  </div>
<script>
(function() {
  // DOM refs expected in the page
  const el = {
    lastUpdated: document.getElementById('lastUpdated'),
    teamsCount: document.getElementById('teamsCount'),
    racersCount: document.getElementById('racersCount'),
    exportsCount: document.getElementById('exportsCount'),
    errorBox: document.getElementById('errorBox'),
    progress: document.getElementById('progress'),
    progressBar: document.getElementById('progressBar'),
    tbodyRacerTeamRaces: document.getElementById('tbody-racer-teamRaces'),
    tbodyTenure: document.getElementById('tbody-tenure'),
    tbodyActive: document.getElementById('tbody-active'),
    tbodyTeamTotals: document.getElementById('tbody-team-totals'),
    previewRacers: document.getElementById('previewRacers'),
    previewTeams: document.getElementById('previewTeams'),
    saveBtn: document.getElementById('saveJSON'),
    reloadBtn: document.getElementById('reloadBtn')
  };

  // Tabs
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(tab.dataset.tab).classList.add('active');
    });
  });

  // Utilities
  function normNumber(x) { const n = Number(x); return Number.isFinite(n) ? n : 0; }
  function textOrEmpty(s) { return s == null ? '' : String(s); }
  function isoDateString(d) { return (d instanceof Date && !isNaN(d)) ? d.toISOString().replace('T',' ').slice(0,19) : '—'; }
  function byDesc(get) { return (a,b) => get(b) - get(a); }
  function byAscDate(get) { return (a,b) => get(a) - get(b); }   // older first
  function byDescDate(get) { return (a,b) => get(b) - get(a); }  // newer first

  // Relative time parser
  function parseRelativeTime(str) {
    if (!str) return new Date(0);
    const s = String(str).trim().toLowerCase();
    if (s === 'never') return new Date(0);
    if (s === 'just now') return new Date();
    const cleaned = s.replace(/^>\s*/, '').replace(/\s+/g, ' ');
    const m = cleaned.match(/^(a|an|\d+)\s+(second|minute|hour|day|week|month|year)s?\s+ago$/);
    if (!m) return new Date(0);
    const qty = (m[1] === 'a' || m[1] === 'an') ? 1 : parseInt(m[1], 10);
    const unit = m[2];
    const ms = { second:1000, minute:60000, hour:3600000, day:86400000, week:604800000, month:2592000000, year:31536000000 }[unit] || 0;
    return new Date(Date.now() - qty * ms);
  }

  // Label helpers
  function safeTeamLabel(t) { return String(t.teamTag || t.teamName || 'Unknown').trim(); }

  // Network with retries
  async function fetchTextWithRetries(url, tries = 3, baseDelay = 500) {
    let lastErr = null;
    for (let i = 0; i < tries; i++) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.text();
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, baseDelay * (i + 1)));
      }
    }
    throw lastErr || new Error('Failed to fetch ' + url);
  }

  // Worker for big JSON
  let worker;
  function ensureWorker() {
    if (worker) return worker;
    const code = `
      self.onmessage = (ev) => {
        const { text } = ev.data || {};
        try {
          const root = JSON.parse(text);

          let teams = [];
          let ingestedCount = 0;
          let rootMetaLast = null;

          if (Array.isArray(root)) {
            teams = root;
            ingestedCount = root.length;
          } else if (root && typeof root === 'object') {
            if (Array.isArray(root.teams)) {
              teams = root.teams;
              ingestedCount = (root.meta && typeof root.meta.filesIngested === 'number') ? root.meta.filesIngested : root.teams.length;
              rootMetaLast = root.meta && root.meta.lastUpdatedISO ? root.meta.lastUpdatedISO : null;
            } else {
              teams = [root];
              ingestedCount = 1;
            }
          }

          const CHUNK = 300;
          for (let i = 0; i < teams.length; i += CHUNK) {
            self.postMessage({ type: 'progress', processed: Math.min(i + CHUNK, teams.length), total: teams.length });
          }

          self.postMessage({ type: 'done', teams, ingestedCount, rootMetaLast });
        } catch (e) {
          self.postMessage({ type: 'error', message: e.message || String(e) });
        }
      };
    `;
    const blob = new Blob([code], { type: 'application/javascript' });
    worker = new Worker(URL.createObjectURL(blob));
    return worker;
  }

  // Dedup by teamTag (latest exportedAtISO)
  function dedupeTeamsByLatest(rawTeams) {
    const index = new Map();
    for (const t of rawTeams) {
      const tag = t.teamTag || t.teamName || 'Unknown';
      const ts = Date.parse(t.exportedAtISO || t.meta?.exportedAtISO || 0) || 0;
      const cur = index.get(tag);
      if (!cur || ts >= cur.ts) index.set(tag, { team: t, ts });
    }
    return Array.from(index.values()).map(v => v.team);
  }

  // Primary racer extraction from roster
  function extractRosterRacers(team) {
    const roster = Array.isArray(team.roster) ? team.roster : [];
    const teamTag = textOrEmpty(team.teamTag);
    return roster.map(m => ({
      username: textOrEmpty(m.username),
      teamTag: textOrEmpty(m.teamTag || teamTag),
      memberSince: textOrEmpty(m.memberSince),
      lastRace: textOrEmpty(m.lastRace),
      teamRaces: normNumber(m.teamRaces),
      totalRaces: normNumber(m.totalRaces),
      avgWPM: normNumber(m.avgWPM),
      highSpeed: normNumber(m.highSpeed),
      source: 'roster'
    }));
  }

  // Fallback inference from stats.raw
  function inferRacersFromStatsRaw(team) {
    const raw = team.stats?.raw || {};
    const teamTag = textOrEmpty(team.teamTag);
    const badKeys = new Set([
      'All Time', 'Last 24 Hours', 'Last24Hours', 'Last 24 Hour', '1', '2', '3'
    ]);
    const racers = [];
    for (const [key, val] of Object.entries(raw)) {
      if (!key) continue;
      const k = String(key).trim();
      if (badKeys.has(k)) continue;
      if (/^\d+$/.test(k)) continue; // numbered block
      if (!val || typeof val !== 'object') continue;

      const avgSpeed = normNumber(val.avgSpeed);
      const avgAccuracy = normNumber(val.avgAccuracy);
      const hasData = Number.isFinite(avgSpeed) || Number.isFinite(avgAccuracy);
      if (!hasData) continue;

      racers.push({
        username: k,               // inferred username label
        teamTag,                   // assume current team
        memberSince: '',           // unknown in raw
        lastRace: '',              // unknown in raw
        teamRaces: 0,              // not available in raw
        totalRaces: 0,             // not available in raw
        avgWPM: avgSpeed,          // map avgSpeed -> avgWPM proxy
        highSpeed: 0,              // unknown
        source: 'stats.raw'
      });
    }
    return racers;
  }

  // Merge duplicates (username+teamTag)
  function mergeRacers(racers) {
    const index = new Map();
    for (const r of racers) {
      const key = `${r.username}::${r.teamTag}`;
      const prev = index.get(key);
      if (!prev) {
        index.set(key, r);
      } else {
        // Prefer roster values; merge numerics by max
        const better = (prev.source === 'roster') ? prev : r;
        index.set(key, {
          username: better.username || prev.username || r.username,
          teamTag: better.teamTag || prev.teamTag || r.teamTag,
          memberSince: better.memberSince || prev.memberSince || r.memberSince,
          lastRace: better.lastRace || prev.lastRace || r.lastRace,
          teamRaces: Math.max(prev.teamRaces || 0, r.teamRaces || 0),
          totalRaces: Math.max(prev.totalRaces || 0, r.totalRaces || 0),
          avgWPM: Math.max(prev.avgWPM || 0, r.avgWPM || 0),
          highSpeed: Math.max(prev.highSpeed || 0, r.highSpeed || 0),
          source: (prev.source === 'roster' || r.source === 'roster') ? 'roster' : 'stats.raw'
        });
      }
    }
    return Array.from(index.values());
  }

  // Build aggregated object for saving and previews
  function buildAggregated(rawTeams, ingestedCount, rootMetaLast) {
    const deduped = dedupeTeamsByLatest(rawTeams);

    // Extract racers (roster + inference)
    const rosterRacers = deduped.flatMap(extractRosterRacers);
    const inferredRacers = deduped.flatMap(inferRacersFromStatsRaw);
    const racers = mergeRacers([...rosterRacers, ...inferredRacers]);

    // Compute lastUpdatedISO
    const teamStamps = deduped
      .map(t => Date.parse(t.exportedAtISO || t.meta?.exportedAtISO || 0) || 0)
      .filter(ts => ts > 0);
    const lastUpdatedISO = rootMetaLast || (teamStamps.length ? new Date(Math.max(...teamStamps)).toISOString() : null);

    // Normalize teams
    const teamsOut = deduped.map(t => ({
      teamTag: textOrEmpty(t.teamTag),
      teamName: textOrEmpty(t.teamName),
      href: textOrEmpty(t.href || t.meta?.href),
      exportedAtISO: textOrEmpty(t.exportedAtISO || t.meta?.exportedAtISO),
      info: {
        members: normNumber(t.info?.members),
        formed: textOrEmpty(t.info?.formed),
        pageViews: normNumber(t.info?.pageViews),
        raw: t.info?.raw || {}
      },
      stats: {
        last24Hours: {
          races: normNumber(t.stats?.last24Hours?.races),
          avgSpeed: normNumber(t.stats?.last24Hours?.avgSpeed),
          avgAccuracy: normNumber(t.stats?.last24Hours?.avgAccuracy)
        },
        allTime: {
          races: normNumber(t.stats?.allTime?.races),
          avgSpeed: normNumber(t.stats?.allTime?.avgSpeed),
          avgAccuracy: normNumber(t.stats?.allTime?.avgAccuracy)
        },
        raw: t.stats?.raw || {}
      }
    }));

    return {
      meta: {
        filesIngested: ingestedCount,
        teamsDeduped: teamsOut.length,
        racersTotal: racers.length,
        inferredRacers: inferredRacers.length,
        rosterRacers: rosterRacers.length,
        lastUpdatedISO
      },
      teams: teamsOut,
      racers
    };
  }

  // Rendering
  function renderSummary(meta) {
    el.teamsCount.textContent = `Teams: ${meta.teamsDeduped}`;
    el.racersCount.textContent = `Racers: ${meta.racersTotal.toLocaleString()} (roster: ${meta.rosterRacers}, inferred: ${meta.inferredRacers})`;
    el.exportsCount.textContent = `Exports ingested: ${meta.filesIngested}`;
    el.lastUpdated.textContent = `Last updated: ${meta.lastUpdatedISO ? new Date(meta.lastUpdatedISO).toLocaleString() : '—'}`;
  }
  function renderTop100(tbody, rows, rowMap) {
    tbody.innerHTML = rows.slice(0, 100).map(rowMap).join('');
  }

  // Leaderboards
  function renderRacerTeamRaces(racers) {
    const top = racers.slice().sort(byDesc(r => r.teamRaces));
    renderTop100(el.tbodyRacerTeamRaces, top, (r, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${r.username}</td>
        <td>${r.teamTag}</td>
        <td class="num">${r.teamRaces.toLocaleString()}</td>
      </tr>
    `);
  }
  function renderTenure(racers) {
    const enriched = racers.map(r => ({ r, sinceDate: parseRelativeTime(r.memberSince) }));
    const top = enriched.slice().sort(byAscDate(x => x.sinceDate));
    renderTop100(el.tbodyTenure, top, (x, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${x.r.username}</td>
        <td>${x.r.teamTag}</td>
        <td>${x.r.memberSince || '—'}</td>
        <td class="num">${isoDateString(x.sinceDate)}</td>
      </tr>
    `);
  }
  function renderActive(racers) {
    const enriched = racers.map(r => ({ r, lastDate: parseRelativeTime(r.lastRace) }));
    const top = enriched.slice().sort(byDescDate(x => x.lastDate));
    renderTop100(el.tbodyActive, top, (x, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${x.r.username}</td>
        <td>${x.r.teamTag}</td>
        <td>${x.r.lastRace || '—'}</td>
        <td class="num">${isoDateString(x.lastDate)}</td>
      </tr>
    `);
  }
  function renderTeamTotals(teams) {
    const rows = teams.map(t => ({
      team: safeTeamLabel(t),
      races: normNumber(t.stats?.allTime?.races),
      avgSpeed: normNumber(t.stats?.allTime?.avgSpeed),
      avgAccuracy: normNumber(t.stats?.allTime?.avgAccuracy),
      href: textOrEmpty(t.href)
    }));
    const top = rows.slice().sort(byDesc(r => r.races));
    renderTop100(el.tbodyTeamTotals, top, (r, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${r.team}</td>
        <td class="num">${r.races.toLocaleString()}</td>
        <td class="num">${r.avgSpeed}</td>
        <td class="num">${r.avgAccuracy}</td>
        <td class="muted">${r.href ? `<a href="${r.href}" target="_blank" rel="noopener">${r.href}</a>` : '—'}</td>
      </tr>
    `);
  }

  // Previews
  function renderPreviews(agg) {
    const sample = agg.racers.slice(0, 50);
    el.previewRacers.innerHTML = sample.map((r, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${r.username}</td>
        <td>${r.teamTag}</td>
        <td class="num">${r.teamRaces.toLocaleString()}</td>
        <td class="num">${r.totalRaces.toLocaleString()}</td>
        <td class="num">${r.avgWPM}</td>
        <td class="num">${r.highSpeed}</td>
        <td>${r.memberSince || '—'}</td>
        <td>${r.lastRace || '—'}</td>
      </tr>
    `).join('');

    el.previewTeams.innerHTML = agg.teams.map((t, i) => `
      <tr>
        <td class="num">${i + 1}</td>
        <td>${t.teamName || t.teamTag || 'Unknown'}</td>
        <td>${t.teamTag || '—'}</td>
        <td class="num">${t.info.members}</td>
        <td>${t.info.formed || '—'}</td>
        <td class="num">${t.info.pageViews.toLocaleString()}</td>
        <td class="num">${t.stats.allTime.races.toLocaleString()}</td>
        <td class="num">${t.stats.allTime.avgSpeed}</td>
        <td class="num">${t.stats.allTime.avgAccuracy}</td>
        <td>${t.exportedAtISO || '—'}</td>
      </tr>
    `).join('');
  }

  // Save aggregated
  let aggregated = null;
  function saveAggregatedJSON() {
    if (!aggregated) return;
    const stamp = (aggregated.meta.lastUpdatedISO || new Date().toISOString()).replace(/[:T]/g, '-').split('.')[0];
    const blob = new Blob([JSON.stringify(aggregated, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `nitrotype_aggregated_${stamp}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Load + render pipeline
  async function loadAndRender() {
    el.errorBox.style.display = 'none';
    el.progress.style.display = 'block';
    el.progressBar.style.width = '0%';
    el.saveBtn.disabled = true;
    aggregated = null;

    let text = '';
    try {
      text = await fetchTextWithRetries('data.json', 3, 600);
    } catch (e) {
      el.errorBox.style.display = 'block';
      el.errorBox.textContent = 'Failed to load data.json: ' + (e.message || String(e));
      el.progress.style.display = 'none';
      return;
    }

    const w = ensureWorker();
    w.onmessage = (ev) => {
      const msg = ev.data || {};
      if (msg.type === 'progress') {
        const pct = msg.total ? Math.round((msg.processed / msg.total) * 100) : 100;
        el.progressBar.style.width = pct + '%';
      } else if (msg.type === 'error') {
        el.errorBox.style.display = 'block';
        el.errorBox.textContent = 'Parse error: ' + msg.message;
        el.progress.style.display = 'none';
      } else if (msg.type === 'done') {
        try {
          const rawTeams = Array.isArray(msg.teams) ? msg.teams : [];
          const ingestedCount = msg.ingestedCount || rawTeams.length;
          const rootMetaLast = msg.rootMetaLast || null;

          aggregated = buildAggregated(rawTeams, ingestedCount, rootMetaLast);

          renderSummary(aggregated.meta);
          renderRacerTeamRaces(aggregated.racers);
          renderTenure(aggregated.racers);
          renderActive(aggregated.racers);
          renderTeamTotals(aggregated.teams);
          renderPreviews(aggregated);

          el.saveBtn.disabled = false;
          el.progressBar.style.width = '100%';
          setTimeout(() => { el.progress.style.display = 'none'; }, 350);
        } catch (e) {
          el.errorBox.style.display = 'block';
          el.errorBox.textContent = 'Render error: ' + (e.message || String(e));
          el.progress.style.display = 'none';
        }
      }
    };
    w.postMessage({ text });
  }

  // Bind actions + autoload
  el.reloadBtn.addEventListener('click', loadAndRender);
  el.saveBtn.addEventListener('click', saveAggregatedJSON);
  loadAndRender();
})();
</script>
</body>
</html>
