<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NitroType Team + Racer Leaderboards (Robust Skull)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #111317;
      --surface: #151922;
      --surface-2: #1b2130;
      --surface-3: #212838;
      --text: #e8ecf1;
      --text-dim: #b5c0cf;
      --muted: #8b9ab3;
      --accent: #6ea8fe;
      --accent-2: #8fdaff;
      --good: #37d67a;
      --warn: #ffb020;
      --bad: #ff5c5c;
      --border: #2a3244;
      --shadow: rgba(0,0,0,0.35);
      --focus: #82b1ff;

      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;

      --pad-1: 0.4rem;
      --pad-2: 0.66rem;
      --pad-3: 1rem;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    html, body { background: var(--bg); color: var(--text); font-family: var(--font); margin: 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .wrap { max-width: 1200px; margin: 0 auto; padding: var(--pad-3); }
    header { display: flex; align-items: center; justify-content: space-between; gap: var(--pad-2); margin-bottom: var(--pad-3); }
    .title { font-size: 1.6rem; font-weight: 700; letter-spacing: .2px; }
    .sub { color: var(--muted); font-size: .95rem; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      background: var(--surface-3);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 6px 12px;
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    input[type="file"] {
      background: var(--surface-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--pad-2);
      outline: none;
    }
    input[type="file"]:focus {
      border-color: var(--focus);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--focus) 25%, transparent);
    }

    .card {
      background: linear-gradient(180deg, var(--surface), var(--surface-2));
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: 0 10px 24px var(--shadow);
      margin-bottom: var(--pad-3);
      overflow: hidden;
    }
    .card h2 {
      margin: 0;
      padding: var(--pad-2) var(--pad-3);
      font-size: 1.15rem;
      border-bottom: 1px solid var(--border);
      background: var(--surface-3);
    }
    .card .body { padding: var(--pad-3); }

    .badge {
      display: inline-block;
      padding: 0.15rem 0.6rem;
      border-radius: var(--radius-sm);
      font-size: 0.85rem;
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text-dim);
    }
    .badges { display: flex; gap: 8px; flex-wrap: wrap; }

    .tabs {
      display: flex; gap: 6px; flex-wrap: wrap; border-bottom: 1px solid var(--border);
      padding: var(--pad-1) var(--pad-2);
    }
    .tab {
      padding: var(--pad-2) var(--pad-3);
      cursor: pointer;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: var(--radius-md) var(--radius-md) 0 0;
      color: var(--text-dim);
      user-select: none;
    }
    .tab.active { background: var(--surface-3); color: var(--text); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    table { width: 100%; border-collapse: collapse; font-size: .94rem; }
    thead th {
      text-align: left; padding: var(--pad-2) var(--pad-3);
      color: var(--text-dim); background: var(--surface-3);
      position: sticky; top: 0; z-index: 1;
    }
    tbody td { padding: var(--pad-2) var(--pad-3); border-top: 1px solid var(--border); vertical-align: middle; }
    tbody tr:hover { background: color-mix(in srgb, var(--surface-2) 70%, var(--surface-3)); }
    .num { font-family: var(--mono); color: var(--text); }
    .muted { color: var(--muted); }
    .scroll { max-height: 560px; overflow: auto; }

    .error { color: var(--bad); margin-top: 6px; }
    .ok { color: var(--good); }
    .warn { color: var(--warn); }

    .progress {
      height: 8px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin-top: 8px;
    }
    .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width .25s ease;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">NitroType Leaderboards (Robust Skull)</div>
        <div class="sub">Loads a large data.json, dedupes teams, extracts racers, and builds top‑100 leaderboards with failsafes.</div>
      </div>
      <div class="controls">
        <button id="reloadBtn">Reload data.json</button>
        <button id="saveJSON" disabled>Save aggregated JSON</button>
        <span class="badge" id="lastUpdated">Last updated: —</span>
      </div>
    </header>

    <div class="card">
      <h2>Summary</h2>
      <div class="body">
        <div class="badges">
          <span class="badge" id="teamsCount">Teams (deduped): 0</span>
          <span class="badge" id="racersCount">Racers: 0</span>
          <span class="badge" id="exportsCount">Exports ingested: 0</span>
          <span class="badge">Dedup: teamTag (fallback teamName), keep latest exportedAtISO</span>
        </div>
        <div id="errorBox" class="error" style="display:none;"></div>
        <div class="progress" id="progress" style="display:none;"><div class="bar" id="progressBar"></div></div>
      </div>
    </div>

    <div class="card">
      <h2>Leaderboards</h2>
      <div class="tabs">
        <div class="tab active" data-tab="lb-racer-teamRaces">Team races (racers)</div>
        <div class="tab" data-tab="lb-tenure">Longest member since (racers)</div>
        <div class="tab" data-tab="lb-active">Most active (racers)</div>
        <div class="tab" data-tab="lb-team-totals">Team total races (stats.allTime)</div>
      </div>

      <div id="lb-racer-teamRaces" class="tab-content active">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th class="num">Team Races</th>
              </tr>
            </thead>
            <tbody id="tbody-racer-teamRaces"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-tenure" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th>Member Since</th>
                <th class="num">Parsed (ISO)</th>
              </tr>
            </thead>
            <tbody id="tbody-tenure"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-active" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Username</th>
                <th>Team</th>
                <th>Last Race</th>
                <th class="num">Parsed (ISO)</th>
              </tr>
            </thead>
            <tbody id="tbody-active"></tbody>
          </table>
        </div>
      </div>

      <div id="lb-team-totals" class="tab-content">
        <div class="scroll">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Team</th>
                <th class="num">All‑Time Races</th>
                <th class="num">Avg Speed</th>
                <th class="num">Avg Accuracy</th>
                <th class="muted">Source URL</th>
              </tr>
            </thead>
            <tbody id="tbody-team-totals"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Preview (first 50 racers)</h2>
      <div class="body scroll">
        <table id="racersTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Username</th>
              <th>Team</th>
              <th class="num">Team Races</th>
              <th class="num">Total Races</th>
              <th class="num">Avg WPM</th>
              <th class="num">High Speed</th>
              <th>Member Since</th>
              <th>Last Race</th>
            </tr>
          </thead>
          <tbody id="previewRacers"></tbody>
        </table>
        <div class="muted" style="margin-top:8px;">Large datasets are processed off the main thread; preview shows only first 50.</div>
      </div>
    </div>

    <div class="card">
      <h2>Preview (teams)</h2>
      <div class="body scroll">
        <table id="teamsTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>Tag</th>
              <th>Members</th>
              <th>Formed</th>
              <th class="num">Page Views</th>
              <th class="num">All‑Time Races</th>
              <th class="num">Avg Speed</th>
              <th class="num">Avg Accuracy</th>
              <th>Exported At</th>
            </tr>
          </thead>
          <tbody id="previewTeams"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    (function() {
      // ----------- Tabs -----------
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab).classList.add('active');
        });
      });

      // ----------- Utilities -----------
      const lastUpdatedEl = document.getElementById('lastUpdated');
      const teamsCountEl = document.getElementById('teamsCount');
      const racersCountEl = document.getElementById('racersCount');
      const exportsCountEl = document.getElementById('exportsCount');
      const errorBox = document.getElementById('errorBox');
      const progress = document.getElementById('progress');
      const progressBar = document.getElementById('progressBar');

      const tbodyRacerTeamRaces = document.getElementById('tbody-racer-teamRaces');
      const tbodyTenure = document.getElementById('tbody-tenure');
      const tbodyActive = document.getElementById('tbody-active');
      const tbodyTeamTotals = document.getElementById('tbody-team-totals');
      const previewRacersEl = document.getElementById('previewRacers');
      const previewTeamsEl = document.getElementById('previewTeams');
      const saveBtn = document.getElementById('saveJSON');
      const reloadBtn = document.getElementById('reloadBtn');

      let aggregated = null;
      let worker = null;

      function normNumber(x) {
        const n = Number(x);
        return Number.isFinite(n) ? n : 0;
      }
      function textOrEmpty(s) { return (s == null) ? '' : String(s); }

      // Robust relative time parser: supports leading ">", a/an, and standard units
      function parseRelativeTime(str) {
        if (!str) return new Date(0);
        const s = String(str).trim().toLowerCase();
        if (s === 'never') return new Date(0);
        if (s === 'just now') return new Date();
        const cleaned = s.replace(/^>\s*/, '').replace(/\s+/g, ' ');
        const m = cleaned.match(/^(a|an|\d+)\s+(second|minute|hour|day|week|month|year)s?\s+ago$/);
        if (!m) return new Date(0);
        const qty = (m[1] === 'a' || m[1] === 'an') ? 1 : parseInt(m[1], 10);
        const unit = m[2];
        const ms = {
          second: 1000,
          minute: 60 * 1000,
          hour:   60 * 60 * 1000,
          day:    24 * 60 * 60 * 1000,
          week:   7 * 24 * 60 * 60 * 1000,
          month:  30 * 24 * 60 * 60 * 1000, // approx
          year:   365 * 24 * 60 * 60 * 1000
        }[unit] || 0;
        return new Date(Date.now() - qty * ms);
      }
      function isoDateString(d) {
        if (!(d instanceof Date) || isNaN(d.getTime())) return '—';
        return d.toISOString().replace('T', ' ').slice(0, 19);
      }
      function byDesc(get) { return (a, b) => get(b) - get(a); }
      function byAscDate(get) { return (a, b) => get(a) - get(b); }
      function byDescDate(get) { return (a, b) => get(b) - get(a); }

      function safeTeamLabel(t) {
        const hdr = t.header || {};
        return String(hdr.teamTag || hdr.teamName || 'Unknown').trim();
      }

      // ----------- Deduplication (failsafe) -----------
      function dedupeTeamsByLatest(rawTeams) {
        const index = new Map();
        for (const t of rawTeams) {
          const hdr = t?.header || {};
          const tag = hdr.teamTag || hdr.teamName || 'Unknown';
          const ts = Date.parse(t?.meta?.exportedAtISO || t?.exportedAtISO || 0) || 0;
          const current = index.get(tag);
          if (!current || ts >= current.ts) index.set(tag, { team: t, ts });
        }
        return Array.from(index.values()).map(v => v.team);
      }

      // ----------- Flatten racers (robust to missing roster) -----------
      function flattenRacers(dedupedTeams) {
        const racers = [];
        for (const t of dedupedTeams) {
          const roster = Array.isArray(t?.roster) ? t.roster : [];
          const teamTag = textOrEmpty(t?.header?.teamTag);
          for (const m of roster) {
            racers.push({
              username: textOrEmpty(m?.username),
              teamTag: textOrEmpty(m?.teamTag || teamTag),
              memberSince: textOrEmpty(m?.memberSince),
              lastRace: textOrEmpty(m?.lastRace),
              teamRaces: normNumber(m?.teamRaces),
              totalRaces: normNumber(m?.totalRaces),
              avgWPM: normNumber(m?.avgWPM),
              highSpeed: normNumber(m?.highSpeed)
            });
          }
        }
        return racers;
      }

      // ----------- Rendering ----------- 
      function renderSummary({ teamsCount, racersCount, ingestedCount, lastUpdatedISO }) {
        teamsCountEl.textContent = `Teams (deduped): ${teamsCount}`;
        racersCountEl.textContent = `Racers: ${racersCount.toLocaleString()}`;
        exportsCountEl.textContent = `Exports ingested: ${ingestedCount}`;
        lastUpdatedEl.textContent = `Last updated: ${lastUpdatedISO ? new Date(lastUpdatedISO).toLocaleString() : '—'}`;
      }
      function renderTop100(tbody, rows, rowMap) {
        tbody.innerHTML = rows.slice(0, 100).map(rowMap).join('');
      }

      function renderRacerTeamRaces(racers) {
        const top = racers.slice().sort(byDesc(r => r.teamRaces));
        renderTop100(tbodyRacerTeamRaces, top, (r, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${r.username}</td>
            <td>${r.teamTag}</td>
            <td class="num">${r.teamRaces.toLocaleString()}</td>
          </tr>
        `);
      }

      // Longest tenure: oldest memberSince first (ascending parsed date)
      function renderTenure(racers) {
        const enriched = racers.map(r => ({ r, sinceDate: parseRelativeTime(r.memberSince) }));
        const top = enriched.slice().sort(byAscDate(x => x.sinceDate));
        renderTop100(tbodyTenure, top, (x, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${x.r.username}</td>
            <td>${x.r.teamTag}</td>
            <td>${x.r.memberSince || '—'}</td>
            <td class="num">${isoDateString(x.sinceDate)}</td>
          </tr>
        `);
      }

      // Most active: most recent lastRace first (descending parsed date)
      function renderActive(racers) {
        const enriched = racers.map(r => ({ r, lastDate: parseRelativeTime(r.lastRace) }));
        const top = enriched.slice().sort(byDescDate(x => x.lastDate));
        renderTop100(tbodyActive, top, (x, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${x.r.username}</td>
            <td>${x.r.teamTag}</td>
            <td>${x.r.lastRace || '—'}</td>
            <td class="num">${isoDateString(x.lastDate)}</td>
          </tr>
        `);
      }

      function renderTeamTotals(dedupedTeams) {
        const rows = dedupedTeams.map(t => {
          const all = t?.stats?.allTime || {};
          return {
            team: safeTeamLabel(t),
            races: normNumber(all.races),
            avgSpeed: normNumber(all.avgSpeed),
            avgAccuracy: normNumber(all.avgAccuracy),
            href: textOrEmpty(t?.meta?.href || t?.href)
          };
        });
        const top = rows.slice().sort(byDesc(r => r.races));
        renderTop100(tbodyTeamTotals, top, (r, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${r.team}</td>
            <td class="num">${r.races.toLocaleString()}</td>
            <td class="num">${r.avgSpeed}</td>
            <td class="num">${r.avgAccuracy}</td>
            <td class="muted">${r.href ? `<a href="${r.href}" target="_blank" rel="noopener">${r.href}</a>` : '—'}</td>
          </tr>
        `);
      }

      function renderPreviews(agg) {
        // Racers preview
        const sample = agg.racers.slice(0, 50);
        previewRacersEl.innerHTML = sample.map((r, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${r.username}</td>
            <td>${r.teamTag}</td>
            <td class="num">${r.teamRaces.toLocaleString()}</td>
            <td class="num">${r.totalRaces.toLocaleString()}</td>
            <td class="num">${r.avgWPM}</td>
            <td class="num">${r.highSpeed}</td>
            <td>${r.memberSince || '—'}</td>
            <td>${r.lastRace || '—'}</td>
          </tr>
        `).join('');

        // Teams preview
        previewTeamsEl.innerHTML = agg.teams.map((t, i) => `
          <tr>
            <td class="num">${i + 1}</td>
            <td>${t.teamName || t.teamTag || 'Unknown'}</td>
            <td>${t.teamTag || '—'}</td>
            <td class="num">${t.info.members}</td>
            <td>${t.info.formed || '—'}</td>
            <td class="num">${t.info.pageViews.toLocaleString()}</td>
            <td class="num">${t.stats.allTime.races.toLocaleString()}</td>
            <td class="num">${t.stats.allTime.avgSpeed}</td>
            <td class="num">${t.stats.allTime.avgAccuracy}</td>
            <td>${t.exportedAtISO || '—'}</td>
          </tr>
        `).join('');
      }

      // ----------- Aggregation (robust) -----------
      function buildAggregated(rawTeams, ingestedCount, rootMetaLast) {
        const dedupedTeams = dedupeTeamsByLatest(rawTeams);
        const racers = flattenRacers(dedupedTeams);

        const timestamps = dedupedTeams
          .map(t => Date.parse(t?.meta?.exportedAtISO || t?.exportedAtISO || 0) || 0)
          .filter(ts => ts > 0);

        const lastUpdatedISO = rootMetaLast || (timestamps.length ? new Date(Math.max(...timestamps)).toISOString() : null);

        const teamsOut = dedupedTeams.map(t => {
          const hdr = t?.header || {};
          const info = t?.info || {};
          const stats = t?.stats || {};
          const meta = t?.meta || {};

          return {
            teamTag: textOrEmpty(hdr.teamTag),
            teamName: textOrEmpty(hdr.teamName),
            href: textOrEmpty(meta.href || t?.href),
            exportedAtISO: textOrEmpty(meta.exportedAtISO || t?.exportedAtISO),
            info: {
              members: normNumber(info.members),
              formed: textOrEmpty(info.formed),
              pageViews: normNumber(info.pageViews),
              raw: info.raw || {}
            },
            stats: {
              last24Hours: {
                races: normNumber(stats?.last24Hours?.races),
                avgSpeed: normNumber(stats?.last24Hours?.avgSpeed),
                avgAccuracy: normNumber(stats?.last24Hours?.avgAccuracy)
              },
              allTime: {
                races: normNumber(stats?.allTime?.races),
                avgSpeed: normNumber(stats?.allTime?.avgSpeed),
                avgAccuracy: normNumber(stats?.allTime?.avgAccuracy)
              },
              raw: stats?.raw || {}
            }
          };
        });

        return {
          meta: {
            filesIngested: ingestedCount,
            teamsDeduped: teamsOut.length,
            racersTotal: racers.length,
            lastUpdatedISO
          },
          teams: teamsOut,
          racers
        };
      }

      // ----------- Web Worker for parsing large JSON ----------- 
      function ensureWorker() {
        if (worker) return worker;
        const code = `
          self.onmessage = (ev) => {
            const { text } = ev.data || {};
            try {
              const root = JSON.parse(text);
              // Normalize: array-of-teams OR root object with teams
              let teams = [];
              let ingestedCount = 0;
              let rootMetaLast = null;

              if (Array.isArray(root)) {
                teams = root;
                ingestedCount = root.length;
              } else if (root && typeof root === 'object') {
                if (Array.isArray(root.teams)) {
                  teams = root.teams;
                  ingestedCount = root.meta && typeof root.meta.filesIngested === 'number' ? root.meta.filesIngested : root.teams.length;
                  rootMetaLast = root.meta && root.meta.lastUpdatedISO ? root.meta.lastUpdatedISO : null;
                } else {
                  teams = [root];
                  ingestedCount = 1;
                }
              }

              // Post chunked to allow progress updates on UI thread
              const CHUNK = 300;
              for (let i = 0; i < teams.length; i += CHUNK) {
                const slice = teams.slice(i, i + CHUNK);
                self.postMessage({ type: 'progress', processed: Math.min(i + CHUNK, teams.length), total: teams.length });
              }

              self.postMessage({ type: 'done', teams, ingestedCount, rootMetaLast });
            } catch (e) {
              self.postMessage({ type: 'error', message: e.message || String(e) });
            }
          };
        `;
        const blob = new Blob([code], { type: 'application/javascript' });
        worker = new Worker(URL.createObjectURL(blob));
        return worker;
      }

      // ----------- Loader with retries/backoff ----------- 
      async function fetchTextWithRetries(url, max = 3) {
        let attempt = 0;
        let lastErr = null;
        while (attempt < max) {
          try {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('HTTP ' + res.status);
            return await res.text();
          } catch (e) {
            lastErr = e;
            await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
            attempt++;
          }
        }
        throw lastErr || new Error('Failed to fetch ' + url);
      }

      // ----------- Boot and render (with failsafes) ----------- 
      async function loadAndRender() {
        errorBox.style.display = 'none';
        progress.style.display = 'block';
        progressBar.style.width = '0%';
        saveBtn.disabled = true;
        aggregated = null;

        let text = '';
        try {
          text = await fetchTextWithRetries('data.json', 3);
        } catch (e) {
          errorBox.style.display = 'block';
          errorBox.textContent = 'Failed to load data.json: ' + (e.message || String(e));
          progress.style.display = 'none';
          return;
        }

        const w = ensureWorker();
        w.onmessage = (ev) => {
          const msg = ev.data || {};
          if (msg.type === 'progress') {
            const pct = msg.total ? Math.round((msg.processed / msg.total) * 100) : 100;
            progressBar.style.width = pct + '%';
          } else if (msg.type === 'error') {
            errorBox.style.display = 'block';
            errorBox.textContent = 'Parse error: ' + msg.message;
            progress.style.display = 'none';
          } else if (msg.type === 'done') {
            try {
              const rawTeams = Array.isArray(msg.teams) ? msg.teams : [];
              const ingestedCount = msg.ingestedCount || rawTeams.length;
              const rootMetaLast = msg.rootMetaLast || null;

              // Build aggregated structure (safe)
              aggregated = buildAggregated(rawTeams, ingestedCount, rootMetaLast);

              // Render summary
              renderSummary({
                teamsCount: aggregated.meta.teamsDeduped,
                racersCount: aggregated.meta.racersTotal,
                ingestedCount: aggregated.meta.filesIngested,
                lastUpdatedISO: aggregated.meta.lastUpdatedISO
              });

              // Leaderboards (guard: if no roster present, racer tabs will be empty)
              renderRacerTeamRaces(aggregated.racers);
              renderTenure(aggregated.racers);
              renderActive(aggregated.racers);
              renderTeamTotals(aggregated.teams);

              // Previews
              renderPreviews(aggregated);

              // Enable save
              saveBtn.disabled = false;
              progressBar.style.width = '100%';
              setTimeout(() => { progress.style.display = 'none'; }, 400);
            } catch (e) {
              errorBox.style.display = 'block';
              errorBox.textContent = 'Render error: ' + (e.message || String(e));
              progress.style.display = 'none';
            }
          }
        };
        // Post text to worker for off-thread parsing
        w.postMessage({ text });
      }

      // ----------- Save aggregated JSON ----------- 
      function saveAggregatedJSON() {
        if (!aggregated) return;
        const stamp = (aggregated.meta.lastUpdatedISO || new Date().toISOString()).replace(/[:T]/g, '-').split('.')[0];
        const blob = new Blob([JSON.stringify(aggregated, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `nitrotype_aggregated_${stamp}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      reloadBtn.addEventListener('click', loadAndRender);
      saveBtn.addEventListener('click', saveAggregatedJSON);

      // Auto-load on open
      loadAndRender();

      // ----------- Defensive guards for huge DOM (optional idle chunk) -----------
      // If you ever need to render extremely large previews, chunk via requestIdleCallback:
      // function idleChunkRender(items, mapFn, targetEl) {
      //   targetEl.innerHTML = '';
      //   let i = 0;
      //   function pump(deadline) {
      //     while (i < items.length && (deadline.timeRemaining() > 5)) {
      //       const row = mapFn(items[i], i);
      //       targetEl.insertAdjacentHTML('beforeend', row);
      //       i++;
      //     }
      //     if (i < items.length) requestIdleCallback(pump);
      //   }
      //   requestIdleCallback(pump);
      // }
    })();
  </script>
</body>
</html>
